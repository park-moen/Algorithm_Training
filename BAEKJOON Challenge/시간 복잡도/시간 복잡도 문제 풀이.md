# 백준 시간 복잡도 틀린 문제 풀이

## 24262번 문제 풀이

### 문제 설명

주어진 입력 값에 대해 시간 복잡도와 그에 상응하는 최고차수 계수를 출력하는 문제입니다.

### 문제 접근 방법

1. 주어진 함수는 배열의 첫 번째 원소를 반환합니다.
2. 이 함수는 배열의 크기 `n`에 관계없이 항상 일정한 시간이 걸립니다.
3. 따라서 이 함수의 시간 복잡도는 O(1)입니다.
4. 출력 형식은 첫 번째 줄에 시간 복잡도 함수 `f(n)`의 실행 횟수, 두 번째 줄에 `f(n)`의 최고차항의 차수입니다.

### 코드 설명

- 주어진 함수는 배열의 첫 번째 원소를 반환하므로 시간 복잡도는 O(1)입니다.
- 따라서 출력은 첫 번째 줄에 1, 두 번째 줄에 0입니다.

## 문제 이해

### 문제 설명

주어진 입력 값에 대해 다음을 출력합니다:

- 시간 복잡도를 나타내는 숫자
- 시간 복잡도의 최고차항의 차수
- 이 문제는 시간 복잡도 분석의 기초적인 개념을 묻는 문제입니다.

### 주어진 함수

```js
function menOfPassion(A, n) {
  return A[0] # code1
}
```

이 함수는 입력 배열 `A`의 첫 번째 원소를 반환합니다. 이 함수의 시간 복잡도를 분석하면 항상 상수 시간(즉, `O(1)`)이 걸립니다.

### 문제 풀이

주어진 함수는 배열의 첫 번째 원소를 반환하는 단순한 작업을 수행합니다. 이 작업은 배열의 크기 `n`에 관계없이 항상 일정한 시간이 걸립니다. 따라서 시간 복잡도는 `O(1)`입니다.

### 출력 형식

- 첫 번째 줄에 시간 복잡도 함수 f(n)의 실행 횟수
- 두 번째 줄에 f(n)의 최고차항의 차수
  위의 예에서 주어진 함수의 시간 복잡도는 O(1)이며, 이는 상수 시간 작업을 의미합니다. 따라서 첫 번째 출력 값은 1이며, 시간 복잡도의 최고차항의 차수는 0입니다. (왜냐하면 상수 시간 작업은 n의 변화에 영향을 받지 않기 때문입니다.)

### 최고차항의 차수

==알고리즘의 시간 복잡도 함수에서 가장 중요한 부분은 입력 크기가 커질 때
가장 큰 영향을 미치는 항입니다. 이를 "최고차항"이라고 부릅니다.==

##### 예제 1

- **시간 복잡도 함수**: \( f(n) = 3n^2 + 2n + 1 \)
- **최고차항**: \( 3n^2 \)
- **시간 복잡도**: \( O(n^2) \)

##### 예제 2

- **시간 복잡도 함수**: \( f(n) = 4n^3 + 3n^2 + 5 \)
- **최고차항**: \( 4n^3 \)
- **시간 복잡도**: \( O(n^3) \)

##### 예제 3

- **시간 복잡도 함수**: \( f(n) = 5n \log n + 2n + 7 \)
- **최고차항**: \( 5n \log n \)
- **시간 복잡도**: \( O(n \log n) \)

</br>

## 24265번 문제 풀이

### 문제 설명

다음 코드의 시간 복잡도를 분석하여, 코드가 몇 번 실행되는지와 시간 복잡도의 최고차항 차수를 출력하는 문제입니다.

### 문제 접근 방법

1. 주어진 함수는 이중 for문을 통해 `cnt`를 증가시킵니다.
2. `i`가 1부터 `n-1`까지 변하고, 각 `i`에 대해 `j`는 `i+1`부터 `n`까지 변합니다.
3. 이를 구체적으로 살펴보면:
   - `i = 1`일 때, `j`는 2부터 `n`까지 변합니다. 즉, `n-1`회 실행됩니다.
   - `i = 2`일 때, `j`는 3부터 `n`까지 변합니다. 즉, `n-2`회 실행됩니다.
   - ...
   - `i = n-1`일 때, `j`는 `n`부터 `n`까지 변합니다. 즉, 1회 실행됩니다.
4. 이 합을 구하면 \( \frac{(n-1)n}{2} \)가 됩니다.
5. 따라서 시간 복잡도는 \( O(n^2) \)이며, 최고차항 차수는 2입니다.

### 최종 코드

```javascript
const fs = require("fs");
const filePath = process.platform === "linux" ? "/dev/stdin" : "input.txt";
const input = fs.readFileSync(filePath).toString().trim().split("\n");

function solution(input) {
  const n = parseInt(input[0]);
  console.log((n * (n - 1)) / 2); // 수행 횟수 출력
  console.log(2); // 시간 복잡도의 최고차항 차수 출력
}

solution(input);
```

### 질문 및 답변

#### 질문 1: i = n-1일 때, j는 왜 1회 실행되나요?

`i = n-1`일 때, `j`는 `n`부터 `n`까지 변합니다. 이는 `j`가 단 한 번만 반복됨을 의미합니다. 예를 들어, `n = 5`인 경우:

- `i = 1`일 때, `j`는 2부터 5까지 4회 실행됩니다.
- `i = 2`일 때, `j`는 3부터 5까지 3회 실행됩니다.
- ...
- `i = 4`일 때, `j`는 5부터 5까지 1회 실행됩니다.

#### 질문 2: 등차수열의 합

이중 for문의 실행 횟수를 계산하기 위해 등차수열의 합을 사용합니다. 등차수열의 합 공식은 다음과 같습니다: \(S = \frac{(n-1)n}{2} \)
여기서 n은 항의 개수입니다.

예를 들어, n = 5인 경우:

$$
S=(5−1)+(5−2)+(5−3)+(5−4)=4+3+2+1=10
$$

이를 일반화하면:

$$
S = \sum\_{k=1}^{n-1} k = \frac{(n-1)n}{2}
$$

$$
합 = \frac{(항수 × (첫항 + 끝항))}{2}
$$

- 항 수: n-1
- 첫 항: 1
- 끝 항: n-1

이를 수식으로 표현하면:

$$
\frac{(n - 1) × (1+(n−1))}{2} = \frac{(n - 1) × n}{2}
$$

따라서, 이중 for문에서 실행되는 횟수는 \( \frac{(n-1)n}{2} \)입니다.

#### 질문 3: 최고차항 차수는 왜 2인가요?

이중 for문을 사용하면, 바깥쪽 for문은 n-1회, 안쪽 for문은 평균적으로 \(\frac{n}{2}\)회 반복됩니다. 이를 종합하면 총 반복 횟수는 \(O(n^2)\)입니다. 따라서 시간 복잡도에서 가장 큰 영향을 미치는 항이 \(n^2\)이므로 최고차항의 차수는 2입니다.
